{"version":3,"file":"SeekStream.js","sourceRoot":"","sources":["../../../play-dl/YouTube/classes/SeekStream.ts"],"names":[],"mappings":"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","sourcesContent":["import { IncomingMessage } from 'node:http';\r\nimport { request_stream } from '../../Request';\r\nimport { parseAudioFormats, StreamOptions, StreamType } from '../stream';\r\nimport { video_stream_info } from '../utils/extractor';\r\nimport { Timer } from './LiveStream';\r\nimport { WebmSeeker, WebmSeekerState } from './WebmSeeker';\r\n\r\n/**\r\n * YouTube Stream Class for seeking audio to a timeStamp.\r\n */\r\nexport class SeekStream {\r\n    /**\r\n     * WebmSeeker Stream through which data passes\r\n     */\r\n    stream: WebmSeeker;\r\n    /**\r\n     * Type of audio data that we recieved from normal youtube url.\r\n     */\r\n    type: StreamType;\r\n    /**\r\n     * Audio Endpoint Format Url to get data from.\r\n     */\r\n    private url: string;\r\n    /**\r\n     * Used to calculate no of bytes data that we have recieved\r\n     */\r\n    private bytes_count: number;\r\n    /**\r\n     * Calculate per second bytes by using contentLength (Total bytes) / Duration (in seconds)\r\n     */\r\n    private per_sec_bytes: number;\r\n    /**\r\n     * Length of the header in bytes\r\n     */\r\n    private header_length: number;\r\n    /**\r\n     * Total length of audio file in bytes\r\n     */\r\n    private content_length: number;\r\n    /**\r\n     * YouTube video url. [ Used only for retrying purposes only. ]\r\n     */\r\n    private video_url: string;\r\n    /**\r\n     * Timer for looping data every 265 seconds.\r\n     */\r\n    private timer: Timer;\r\n    /**\r\n     * Quality given by user. [ Used only for retrying purposes only. ]\r\n     */\r\n    private quality: number;\r\n    /**\r\n     * Incoming message that we recieve.\r\n     *\r\n     * Storing this is essential.\r\n     * This helps to destroy the TCP connection completely if you stopped player in between the stream\r\n     */\r\n    private request: IncomingMessage | null;\r\n    /**\r\n     * YouTube Stream Class constructor\r\n     * @param url Audio Endpoint url.\r\n     * @param type Type of Stream\r\n     * @param duration Duration of audio playback [ in seconds ]\r\n     * @param headerLength Length of the header in bytes.\r\n     * @param contentLength Total length of Audio file in bytes.\r\n     * @param video_url YouTube video url.\r\n     * @param options Options provided to stream function.\r\n     */\r\n    constructor(\r\n        url: string,\r\n        duration: number,\r\n        headerLength: number,\r\n        contentLength: number,\r\n        bitrate: number,\r\n        video_url: string,\r\n        options: StreamOptions\r\n    ) {\r\n        this.stream = new WebmSeeker(options.seek!, {\r\n            highWaterMark: 5 * 1000 * 1000,\r\n            readableObjectMode: true\r\n        });\r\n        this.url = url;\r\n        this.quality = options.quality as number;\r\n        this.type = StreamType.Opus;\r\n        this.bytes_count = 0;\r\n        this.video_url = video_url;\r\n        this.per_sec_bytes = bitrate ? Math.ceil(bitrate / 8) : Math.ceil(contentLength / duration);\r\n        this.header_length = headerLength;\r\n        this.content_length = contentLength;\r\n        this.request = null;\r\n        this.timer = new Timer(() => {\r\n            this.timer.reuse();\r\n            this.loop();\r\n        }, 265);\r\n        this.stream.on('close', () => {\r\n            this.timer.destroy();\r\n            this.cleanup();\r\n        });\r\n        this.seek();\r\n    }\r\n    /**\r\n     * **INTERNAL Function**\r\n     *\r\n     * Uses stream functions to parse Webm Head and gets Offset byte to seek to.\r\n     * @returns Nothing\r\n     */\r\n    private async seek(): Promise<void> {\r\n        const parse = await new Promise(async (res, rej) => {\r\n            if (!this.stream.headerparsed) {\r\n                const stream = await request_stream(this.url, {\r\n                    headers: {\r\n                        range: `bytes=0-${this.header_length}`\r\n                    }\r\n                }).catch((err: Error) => err);\r\n\r\n                if (stream instanceof Error) {\r\n                    rej(stream);\r\n                    return;\r\n                }\r\n                if (Number(stream.statusCode) >= 400) {\r\n                    rej(400);\r\n                    return;\r\n                }\r\n                this.request = stream;\r\n                stream.pipe(this.stream, { end: false });\r\n\r\n                // headComplete should always be called, leaving this here just in case\r\n                stream.once('end', () => {\r\n                    this.stream.state = WebmSeekerState.READING_DATA;\r\n                    res('');\r\n                });\r\n\r\n                this.stream.once('headComplete', () => {\r\n                    stream.unpipe(this.stream);\r\n                    stream.destroy();\r\n                    this.stream.state = WebmSeekerState.READING_DATA;\r\n                    res('');\r\n                });\r\n            } else res('');\r\n        }).catch((err) => err);\r\n        if (parse instanceof Error) {\r\n            this.stream.emit('error', parse);\r\n            this.bytes_count = 0;\r\n            this.per_sec_bytes = 0;\r\n            this.cleanup();\r\n            return;\r\n        } else if (parse === 400) {\r\n            await this.retry();\r\n            this.timer.reuse();\r\n            return this.seek();\r\n        }\r\n        const bytes = this.stream.seek(this.content_length);\r\n        if (bytes instanceof Error) {\r\n            this.stream.emit('error', bytes);\r\n            this.bytes_count = 0;\r\n            this.per_sec_bytes = 0;\r\n            this.cleanup();\r\n            return;\r\n        }\r\n\r\n        this.stream.seekfound = false;\r\n        this.bytes_count = bytes;\r\n        this.timer.reuse();\r\n        this.loop();\r\n    }\r\n    /**\r\n     * Retry if we get 404 or 403 Errors.\r\n     */\r\n    private async retry() {\r\n        const info = await video_stream_info(this.video_url);\r\n        const audioFormat = parseAudioFormats(info.format);\r\n        this.url = audioFormat[this.quality].url;\r\n    }\r\n    /**\r\n     * This cleans every used variable in class.\r\n     *\r\n     * This is used to prevent re-use of this class and helping garbage collector to collect it.\r\n     */\r\n    private cleanup() {\r\n        this.request?.destroy();\r\n        this.request = null;\r\n        this.url = '';\r\n    }\r\n    /**\r\n     * Getting data from audio endpoint url and passing it to stream.\r\n     *\r\n     * If 404 or 403 occurs, it will retry again.\r\n     */\r\n    private async loop() {\r\n        if (this.stream.destroyed) {\r\n            this.timer.destroy();\r\n            this.cleanup();\r\n            return;\r\n        }\r\n        const end: number = this.bytes_count + this.per_sec_bytes * 300;\r\n        const stream = await request_stream(this.url, {\r\n            headers: {\r\n                range: `bytes=${this.bytes_count}-${end >= this.content_length ? '' : end}`\r\n            }\r\n        }).catch((err: Error) => err);\r\n        if (stream instanceof Error) {\r\n            this.stream.emit('error', stream);\r\n            this.bytes_count = 0;\r\n            this.per_sec_bytes = 0;\r\n            this.cleanup();\r\n            return;\r\n        }\r\n        if (Number(stream.statusCode) >= 400) {\r\n            this.cleanup();\r\n            await this.retry();\r\n            this.timer.reuse();\r\n            this.loop();\r\n            return;\r\n        }\r\n        this.request = stream;\r\n        stream.pipe(this.stream, { end: false });\r\n\r\n        stream.once('error', async () => {\r\n            this.cleanup();\r\n            await this.retry();\r\n            this.timer.reuse();\r\n            this.loop();\r\n        });\r\n\r\n        stream.on('data', (chunk: any) => {\r\n            this.bytes_count += chunk.length;\r\n        });\r\n\r\n        stream.on('end', () => {\r\n            if (end >= this.content_length) {\r\n                this.timer.destroy();\r\n                this.stream.end();\r\n                this.cleanup();\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Pauses timer.\r\n     * Stops running of loop.\r\n     *\r\n     * Useful if you don't want to get excess data to be stored in stream.\r\n     */\r\n    pause() {\r\n        this.timer.pause();\r\n    }\r\n    /**\r\n     * Resumes timer.\r\n     * Starts running of loop.\r\n     */\r\n    resume() {\r\n        this.timer.resume();\r\n    }\r\n}\r\n"]}