{"version":3,"file":"LiveStream.js","sourceRoot":"","sources":["../../../play-dl/YouTube/classes/LiveStream.ts"],"names":[],"mappings":"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","sourcesContent":["import { Readable } from 'node:stream';\r\nimport { IncomingMessage } from 'node:http';\r\nimport { parseAudioFormats, StreamOptions, StreamType } from '../stream';\r\nimport { request, request_stream } from '../../Request';\r\nimport { video_stream_info } from '../utils/extractor';\r\nimport { URL } from 'node:url';\r\n\r\n/**\r\n * YouTube Live Stream class for playing audio from Live Stream videos.\r\n */\r\nexport class LiveStream {\r\n    /**\r\n     * Readable Stream through which data passes\r\n     */\r\n    stream: Readable;\r\n    /**\r\n     * Type of audio data that we recieved from live stream youtube url.\r\n     */\r\n    type: StreamType;\r\n    /**\r\n     * Incoming message that we recieve.\r\n     *\r\n     * Storing this is essential.\r\n     * This helps to destroy the TCP connection completely if you stopped player in between the stream\r\n     */\r\n    private request?: IncomingMessage;\r\n    /**\r\n     * Timer that creates loop from interval time provided.\r\n     */\r\n    private normal_timer?: Timer;\r\n    /**\r\n     * Timer used to update dash url so as to avoid 404 errors after long hours of streaming.\r\n     *\r\n     * It updates dash_url every 30 minutes.\r\n     */\r\n    private dash_timer: Timer;\r\n    /**\r\n     * Given Dash URL.\r\n     */\r\n    private dash_url: string;\r\n    /**\r\n     * Base URL in dash manifest file.\r\n     */\r\n    private base_url: string;\r\n    /**\r\n     * Interval to fetch data again to dash url.\r\n     */\r\n    private interval: number;\r\n    /**\r\n     * Timer used to update dash url so as to avoid 404 errors after long hours of streaming.\r\n     *\r\n     * It updates dash_url every 30 minutes.\r\n     */\r\n    private video_url: string;\r\n    /**\r\n     * No of segments of data to add in stream before starting to loop\r\n     */\r\n    private precache: number;\r\n    /**\r\n     * Segment sequence number\r\n     */\r\n    private sequence: number;\r\n    /**\r\n     * Live Stream Class Constructor\r\n     * @param dash_url dash manifest URL\r\n     * @param target_interval interval time for fetching dash data again\r\n     * @param video_url Live Stream video url.\r\n     */\r\n    constructor(dash_url: string, interval: number, video_url: string, precache?: number) {\r\n        this.stream = new Readable({ highWaterMark: 5 * 1000 * 1000, read() {} });\r\n        this.type = StreamType.Arbitrary;\r\n        this.sequence = 0;\r\n        this.dash_url = dash_url;\r\n        this.base_url = '';\r\n        this.interval = interval;\r\n        this.video_url = video_url;\r\n        this.precache = precache || 3;\r\n        this.dash_timer = new Timer(() => {\r\n            this.dash_updater();\r\n            this.dash_timer.reuse();\r\n        }, 1800);\r\n        this.stream.on('close', () => {\r\n            this.cleanup();\r\n        });\r\n        this.initialize_dash();\r\n    }\r\n    /**\r\n     * This cleans every used variable in class.\r\n     *\r\n     * This is used to prevent re-use of this class and helping garbage collector to collect it.\r\n     */\r\n    private cleanup() {\r\n        this.normal_timer?.destroy();\r\n        this.dash_timer.destroy();\r\n        this.request?.destroy();\r\n        this.video_url = '';\r\n        this.request = undefined;\r\n        this.dash_url = '';\r\n        this.base_url = '';\r\n        this.interval = 0;\r\n    }\r\n    /**\r\n     * Updates dash url.\r\n     *\r\n     * Used by dash_timer for updating dash_url every 30 minutes.\r\n     */\r\n    private async dash_updater() {\r\n        const info = await video_stream_info(this.video_url);\r\n        if (info.LiveStreamData.dashManifestUrl) this.dash_url = info.LiveStreamData.dashManifestUrl;\r\n        return this.initialize_dash();\r\n    }\r\n    /**\r\n     * Initializes dash after getting dash url.\r\n     *\r\n     * Start if it is first time of initialishing dash function.\r\n     */\r\n    private async initialize_dash() {\r\n        const response = await request(this.dash_url);\r\n        const audioFormat = response\r\n            .split('<AdaptationSet id=\"0\"')[1]\r\n            .split('</AdaptationSet>')[0]\r\n            .split('</Representation>');\r\n        if (audioFormat[audioFormat.length - 1] === '') audioFormat.pop();\r\n        this.base_url = audioFormat[audioFormat.length - 1].split('<BaseURL>')[1].split('</BaseURL>')[0];\r\n        await request_stream(`https://${new URL(this.base_url).host}/generate_204`);\r\n        if (this.sequence === 0) {\r\n            const list = audioFormat[audioFormat.length - 1]\r\n                .split('<SegmentList>')[1]\r\n                .split('</SegmentList>')[0]\r\n                .replaceAll('<SegmentURL media=\"', '')\r\n                .split('\"/>');\r\n            if (list[list.length - 1] === '') list.pop();\r\n            if (list.length > this.precache) list.splice(0, list.length - this.precache);\r\n            this.sequence = Number(list[0].split('sq/')[1].split('/')[0]);\r\n            this.first_data(list.length);\r\n        }\r\n    }\r\n    /**\r\n     * Used only after initializing dash function first time.\r\n     * @param len Length of data that you want to\r\n     */\r\n    private async first_data(len: number) {\r\n        for (let i = 1; i <= len; i++) {\r\n            await new Promise(async (resolve) => {\r\n                const stream = await request_stream(this.base_url + 'sq/' + this.sequence).catch((err: Error) => err);\r\n                if (stream instanceof Error) {\r\n                    this.stream.emit('error', stream);\r\n                    return;\r\n                }\r\n                this.request = stream;\r\n                stream.on('data', (c) => {\r\n                    this.stream.push(c);\r\n                });\r\n                stream.on('end', () => {\r\n                    this.sequence++;\r\n                    resolve('');\r\n                });\r\n                stream.once('error', (err) => {\r\n                    this.stream.emit('error', err);\r\n                });\r\n            });\r\n        }\r\n        this.normal_timer = new Timer(() => {\r\n            this.loop();\r\n            this.normal_timer?.reuse();\r\n        }, this.interval);\r\n    }\r\n    /**\r\n     * This loops function in Live Stream Class.\r\n     *\r\n     * Gets next segment and push it.\r\n     */\r\n    private loop() {\r\n        return new Promise(async (resolve) => {\r\n            const stream = await request_stream(this.base_url + 'sq/' + this.sequence).catch((err: Error) => err);\r\n            if (stream instanceof Error) {\r\n                this.stream.emit('error', stream);\r\n                return;\r\n            }\r\n            this.request = stream;\r\n            stream.on('data', (c) => {\r\n                this.stream.push(c);\r\n            });\r\n            stream.on('end', () => {\r\n                this.sequence++;\r\n                resolve('');\r\n            });\r\n            stream.once('error', (err) => {\r\n                this.stream.emit('error', err);\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * Deprecated Functions\r\n     */\r\n    pause() {}\r\n    /**\r\n     * Deprecated Functions\r\n     */\r\n    resume() {}\r\n}\r\n/**\r\n * YouTube Stream Class for playing audio from normal videos.\r\n */\r\nexport class Stream {\r\n    /**\r\n     * Readable Stream through which data passes\r\n     */\r\n    stream: Readable;\r\n    /**\r\n     * Type of audio data that we recieved from normal youtube url.\r\n     */\r\n    type: StreamType;\r\n    /**\r\n     * Audio Endpoint Format Url to get data from.\r\n     */\r\n    private url: string;\r\n    /**\r\n     * Used to calculate no of bytes data that we have recieved\r\n     */\r\n    private bytes_count: number;\r\n    /**\r\n     * Calculate per second bytes by using contentLength (Total bytes) / Duration (in seconds)\r\n     */\r\n    private per_sec_bytes: number;\r\n    /**\r\n     * Total length of audio file in bytes\r\n     */\r\n    private content_length: number;\r\n    /**\r\n     * YouTube video url. [ Used only for retrying purposes only. ]\r\n     */\r\n    private video_url: string;\r\n    /**\r\n     * Timer for looping data every 265 seconds.\r\n     */\r\n    private timer: Timer;\r\n    /**\r\n     * Quality given by user. [ Used only for retrying purposes only. ]\r\n     */\r\n    private quality: number;\r\n    /**\r\n     * Incoming message that we recieve.\r\n     *\r\n     * Storing this is essential.\r\n     * This helps to destroy the TCP connection completely if you stopped player in between the stream\r\n     */\r\n    private request: IncomingMessage | null;\r\n    /**\r\n     * YouTube Stream Class constructor\r\n     * @param url Audio Endpoint url.\r\n     * @param type Type of Stream\r\n     * @param duration Duration of audio playback [ in seconds ]\r\n     * @param contentLength Total length of Audio file in bytes.\r\n     * @param video_url YouTube video url.\r\n     * @param options Options provided to stream function.\r\n     */\r\n    constructor(\r\n        url: string,\r\n        type: StreamType,\r\n        duration: number,\r\n        contentLength: number,\r\n        video_url: string,\r\n        options: StreamOptions\r\n    ) {\r\n        this.stream = new Readable({ highWaterMark: 5 * 1000 * 1000, read() {} });\r\n        this.url = url;\r\n        this.quality = options.quality as number;\r\n        this.type = type;\r\n        this.bytes_count = 0;\r\n        this.video_url = video_url;\r\n        this.per_sec_bytes = Math.ceil(contentLength / duration);\r\n        this.content_length = contentLength;\r\n        this.request = null;\r\n        this.timer = new Timer(() => {\r\n            this.timer.reuse();\r\n            this.loop();\r\n        }, 265);\r\n        this.stream.on('close', () => {\r\n            this.timer.destroy();\r\n            this.cleanup();\r\n        });\r\n        this.loop();\r\n    }\r\n    /**\r\n     * Retry if we get 404 or 403 Errors.\r\n     */\r\n    private async retry() {\r\n        const info = await video_stream_info(this.video_url);\r\n        const audioFormat = parseAudioFormats(info.format);\r\n        this.url = audioFormat[this.quality].url;\r\n    }\r\n    /**\r\n     * This cleans every used variable in class.\r\n     *\r\n     * This is used to prevent re-use of this class and helping garbage collector to collect it.\r\n     */\r\n    private cleanup() {\r\n        this.request?.destroy();\r\n        this.request = null;\r\n        this.url = '';\r\n    }\r\n    /**\r\n     * Getting data from audio endpoint url and passing it to stream.\r\n     *\r\n     * If 404 or 403 occurs, it will retry again.\r\n     */\r\n    private async loop() {\r\n        if (this.stream.destroyed) {\r\n            this.timer.destroy();\r\n            this.cleanup();\r\n            return;\r\n        }\r\n        const end: number = this.bytes_count + this.per_sec_bytes * 300;\r\n        const stream = await request_stream(this.url, {\r\n            headers: {\r\n                range: `bytes=${this.bytes_count}-${end >= this.content_length ? '' : end}`\r\n            }\r\n        }).catch((err: Error) => err);\r\n        if (stream instanceof Error) {\r\n            this.stream.emit('error', stream);\r\n            this.bytes_count = 0;\r\n            this.per_sec_bytes = 0;\r\n            this.cleanup();\r\n            return;\r\n        }\r\n        if (Number(stream.statusCode) >= 400) {\r\n            this.cleanup();\r\n            await this.retry();\r\n            this.timer.reuse();\r\n            this.loop();\r\n            return;\r\n        }\r\n        this.request = stream;\r\n        stream.on('data', (c) => {\r\n            this.stream.push(c);\r\n        });\r\n\r\n        stream.once('error', async () => {\r\n            this.cleanup();\r\n            await this.retry();\r\n            this.timer.reuse();\r\n            this.loop();\r\n        });\r\n\r\n        stream.on('data', (chunk: any) => {\r\n            this.bytes_count += chunk.length;\r\n        });\r\n\r\n        stream.on('end', () => {\r\n            if (end >= this.content_length) {\r\n                this.timer.destroy();\r\n                this.stream.push(null);\r\n                this.cleanup();\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Pauses timer.\r\n     * Stops running of loop.\r\n     *\r\n     * Useful if you don't want to get excess data to be stored in stream.\r\n     */\r\n    pause() {\r\n        this.timer.pause();\r\n    }\r\n    /**\r\n     * Resumes timer.\r\n     * Starts running of loop.\r\n     */\r\n    resume() {\r\n        this.timer.resume();\r\n    }\r\n}\r\n/**\r\n * Timer Class.\r\n *\r\n * setTimeout + extra features ( re-starting, pausing, resuming ).\r\n */\r\nexport class Timer {\r\n    /**\r\n     * Boolean for checking if Timer is destroyed or not.\r\n     */\r\n    private destroyed: boolean;\r\n    /**\r\n     * Boolean for checking if Timer is paused or not.\r\n     */\r\n    private paused: boolean;\r\n    /**\r\n     * setTimeout function\r\n     */\r\n    private timer: NodeJS.Timer;\r\n    /**\r\n     * Callback to be executed once timer finishes.\r\n     */\r\n    private callback: () => void;\r\n    /**\r\n     * Seconds time when it is started.\r\n     */\r\n    private time_start: number;\r\n    /**\r\n     * Total time left.\r\n     */\r\n    private time_left: number;\r\n    /**\r\n     * Total time given by user [ Used only for re-using timer. ]\r\n     */\r\n    private time_total: number;\r\n    /**\r\n     * Constructor for Timer Class\r\n     * @param callback Function to execute when timer is up.\r\n     * @param time Total time to wait before execution.\r\n     */\r\n    constructor(callback: () => void, time: number) {\r\n        this.callback = callback;\r\n        this.time_total = time;\r\n        this.time_left = time;\r\n        this.paused = false;\r\n        this.destroyed = false;\r\n        this.time_start = process.hrtime()[0];\r\n        this.timer = setTimeout(this.callback, this.time_total * 1000);\r\n    }\r\n    /**\r\n     * Pauses Timer\r\n     * @returns Boolean to tell that if it is paused or not.\r\n     */\r\n    pause() {\r\n        if (!this.paused && !this.destroyed) {\r\n            this.paused = true;\r\n            clearTimeout(this.timer);\r\n            this.time_left = this.time_left - (process.hrtime()[0] - this.time_start);\r\n            return true;\r\n        } else return false;\r\n    }\r\n    /**\r\n     * Resumes Timer\r\n     * @returns Boolean to tell that if it is resumed or not.\r\n     */\r\n    resume() {\r\n        if (this.paused && !this.destroyed) {\r\n            this.paused = false;\r\n            this.time_start = process.hrtime()[0];\r\n            this.timer = setTimeout(this.callback, this.time_left * 1000);\r\n            return true;\r\n        } else return false;\r\n    }\r\n    /**\r\n     * Reusing of timer\r\n     * @returns Boolean to tell if it is re-used or not.\r\n     */\r\n    reuse() {\r\n        if (!this.destroyed) {\r\n            clearTimeout(this.timer);\r\n            this.time_left = this.time_total;\r\n            this.paused = false;\r\n            this.time_start = process.hrtime()[0];\r\n            this.timer = setTimeout(this.callback, this.time_total * 1000);\r\n            return true;\r\n        } else return false;\r\n    }\r\n    /**\r\n     * Destroy timer.\r\n     *\r\n     * It can't be used again.\r\n     */\r\n    destroy() {\r\n        clearTimeout(this.timer);\r\n        this.destroyed = true;\r\n        this.callback = () => {};\r\n        this.time_total = 0;\r\n        this.time_left = 0;\r\n        this.paused = false;\r\n        this.time_start = 0;\r\n    }\r\n}\r\n"]}